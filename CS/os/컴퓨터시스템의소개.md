# 컴퓨터 시스템의 소개

<hr>

## 01 프로세스

* 하드웨어 : 데이터를 처리하는 물리적인 기계장치
	* 프로세서 , 메모리(기억장치), 주변장치
		* 시스템 버스로 연결

* 소프트웨어 : 어떤 작업을 지시하는 명령어로 작성한 프로그램

* RAM(Random Access Memory):휘발성

* ROM(Read Only Memory):비휘발성

<img width="697" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/adf885dc-9dce-461a-ab8a-69cec933e83f">

#### 프로세서 CPU (중앙처리장치) 
* 운영체제와 가장 밀접한 부분 , 컴퓨터 모든 장치 동작 제어 , 연산 수행

<img width="655" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/093b248d-99fe-4593-b134-6f3463189875">


#### 프로세스의 레지스터

* 용도에 따라서
	* 전용 레지스터
	* 범용 레지스터

* 사용자 정보 변경 가능 여부에 따라서
	* 사용자 가시(user-visible) 레지스터
	* 사용자 불가시(user-invisible) 레지스터

* 저장 정보 종류에 따라서
	* 데이터 레지스터
	* 주소 레지스터
	* 상태 레지스터

#### 프로세스의 기본 레지스터

<img width="526" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/bb80491f-31fb-4fb2-97ef-217811eed264">



#### 사용자 가시 레지스터

* 데이터 레지스터

* 주소 레지스터
	* 기준 주소 레지스터 : 기준 주소 값을 저장
	* 인덱스 레지스터 : 유효 주소를 계산
	* 스택 포인터 레지스터 : 프로세서 스택을 구현

* ❗️기준 주소 int num [5] 메모리 base 주소값 지정 으로부터 int면 4바이트 씩 + 한다 참고해서 정리


#### 사용자 불가시 레지스터

> 사용자가 정보를 변경할 수 없는 레지스터이다. 프로세서의 상태와 제어를 관리

* 프로그램 카운터
	* 다음에 실행할 명령어의 주소를 보관

* 명령어 레지스터
	* 현재 실행하는 명령어를 보관

* 누산기
	* 데이터를 일시적으로 저장

* 메모리 주소 레지스터
	* 프로세서가 참조 , 데이터의 주소를 명시하여 메모리에 접근

* 메모리 버퍼 레지스터
	* 프로세서가 메모리에서 읽거나 메모리에 저장할 데이터 자체를 보관


## 02 메모리

#### 메모리 계층 구조
> 1950 - 1960년대 너무 비싼 메인 메모리의 가격 문제 때문에 제안한 방법
> 메모리를 계층적으로 구성하여 비용, 속도, 용량, 접근시간 등을 상호 보완

* 올라갈수록 속도가 빠르고 , 용량이 적다

* 레지스터
	* 프로세서 내부 , 프로세서가 사용할 데이터를 보관하는 가장 빠른 메모리
   
<img width="780" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/14d09f0e-9045-4158-afe3-2ae45d005ba7">


#### 메인 메모리

* 프로세서 외부 , 수행할 프로그램과 데이터 저장
* 주기억장치 또는 1차 기억장치라고도 한다. 저장 밀도가 높고 가격이 싼 DRAM(Dynamic RAM) 많이 사용
* 다수의 셀로 구성되며 , 각 셀은 비트로 구성
* 셀이 K비트이면 셀에 2^k 값 저장 가능
* 메인 메모리에 데이터를 저장할 때는 셀 한개나 여러 개에 나눠서 저장
* 셀은 주소를 참조하는데, n비트이라면 주소 범위는 0 ~ 2^n-1
* 프로세서와 보조 기억장치 사이에 있으며, "디스크 입출력 병목 현상" 해결하는 역할 수행
* 프로세서와 메인 메모리 간 속도 차이 부담 줄이기 위해 프로세서 내부나 외부에 캐시를 구현하기도 함.

<img width="648" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/e961d207-de30-4749-aef9-36669fa892e7">


* Q1. 8*8 bit RAM의 경우 주소비트는 몇 개 필요한가?
* Q2. 1K*8bit RAM?
* Q3. 512K*8bit RAM?
* Q4. 16M*8bit RAM?

<img width="376" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/4a921051-5236-47f5-ad46-09edc443d343">

<img width="697" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/8a906b4d-0cfe-4d87-aed8-3f9d6023a306">


* 메모리 매핑
> mapping : 사상

* 컴파일로 논리적 주소를 물리적 주소로 변환하는 과정

<img width="480" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/0ceb7b6c-549d-4ba5-8c4e-5e19fd44ec0e">


* 메모리 속도
	* 메모리 접근시간과 메모리 사이클 시간으로 표현

<img width="490" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/1fe3c4e0-e7a1-4fae-b06a-2efb42093b25">


* 캐시
	* 빠른 프로세서와 상대적으로 느린 주기억 장치의 속도 차이를 보완하는 메모리
	* 프로세서 내부나 외부에 있으며, 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리의 속도 차이를 보완하는 고속 버퍼
		* 메인 메모리에서 데이터를 블록 단위로 가져와 프로세서에 워드 단위로 전달하여 속도를 높임
		* 데이터가 이동하는 통로(대역폭)를 확대하여 프로세서와 메모리의 속도 차이를 줄임
	* 캐시의 성능은 작은 용량의 캐시에 프로세서가 이후 참조할 정보가 얼마나 들어있느냐로 좌우됨
   		* 캐시 적중(캐시 히트) : 프로세서가 참조하려는 정보가 있을 때
       		> cache hit
       		* 캐시 실패(캐시 미스) : 프로세서가 참조하려는 정보가 없을 때
           	> cache miss
       * 블록의 크기는 캐시의 성능으로 좌우되는데, 실제 프로그램을 실행할 때 참조한 메모리에 대한 공간적 지역성(국부성)과 시간적 지역성(국부성)이 있기 때문
  
		* 공간적 지역성(spatial locality) : 대부분의 프로그램이 참조한 주소와 인접한 주소의 내용을 다시 참조하는 특성

		* 시간적 지역성(temporal locality) : 한 번 참조한 주소를 곧 다시 참조하는 특성
	* 공간적 지역성과 시간적 지역성의 발생 원인
 		* 프로그램이 명령어를 순차적으로 실행하는 경항이 있어 명령어가 특정 지역 메모리에 인접해 있다.
   		* 순환(단일 순환, 중첩 순환 등) 때문에 프로그램을 반복하더라도 메모리는 일부 영역만 참조한다.
     		* 대부분의 컴파일러를 메모리에 인접한 블록에 배열로 저장한다. 따라서 프로그램이 배열 원소에 순차적으로 자주 접근하므로 지역적인 배열 접근 경향이 있다.
  
	-> 지역성은 블록이 크면 캐시의 히트율이 올라갈 수 있음을 의미하지만, 블록이 커지면 이에 따른 전송 부담과 캐시 데이터 교체 작업이 자주 일어나므로 블록 크기를 무작정 늘릴 수는 없음 



<img width="613" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/ac908294-6b54-4dd2-8705-5daddcd3d5ab">

* 캐시의 기본 동작

<img width="832" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/64c9320f-cd77-4034-a14b-e5ea81ee7ec5">


* 보조기억장치
	* 대용량의 자기디스크, 이동이 편리한 광디스크, 파일을 저장하는 속도가 느린 자기테이프
 	* 주변장치 중 프로그램과 데이터를 저장하는 하드웨어
  	* 2차 기억장치 또는 외부 기억장치
 
* 시스템 버스
> system bus

	* 하드웨어를 물리적으로 연결하여 서로 데이터를 주고 받을 수 있게 하는 통로
 	* 컴퓨터 내부의 다양한 신호(데이터 입출력 신호 , 프로세서 상태 신호, 인터럽트 요구와 허가 신호, 클록(clock) 신호)를 시스템 버스로 전달

  	* 기능에 따라 데이터 버스 , 주소 버스 , 제어 버스로 구분

<img width="330" alt="image" src="https://github.com/amazon7737/think-container/assets/76634341/f5aef846-6e09-4849-a40d-2bbe574126f1">

#### 시스템 버스의 종류

* 데이터 버스
  * 프로세서와 메인 메모리 , 주변 장치 사이에서 데이터를 전송한다. 데이터 버스를 구성하는 배선 수는 프로세서가 한 번에 전송할 수 있는 비트 수를 결정하는데, 이를 워드라고 한다.
    
* 주소 버스
  * 프로세서가 시스템의 구성 요소를 식별하는 주소 정보를 전송한다. 주소 버스를 구성하는 배선 수는 프로세서와 접속할 수 있는 메인 메모리의 최대 용량을 결정한다.

* 제어 버스
  * 프로세서가 시스템의 구성 요소를 제어하는 데 사용한다. 제어 신호로 연산장치의 연산 종류와 메인 메모리의 읽기나 쓰기 동작을 결정한다.

#### 주변장치

 * 프로세서와 메인 메모리를 제외한 나머지 하드웨어 구성 요소
 * 크게 입력장치 , 출력장치 , 저장장치로 구분
   * 입력장치
     - 컴퓨터에서 처리할 데이터를 외부에서 입력하는 장치
   * 출력장치
     - 입력장치와 반대로 컴퓨터에서 처리한 데이터를 외부로 보내는 장치
   * 저장장치
     - 메인 메모리와 달리 거의 영구적으로 데이터를 저장하는 장치. 데이터를 입력하여 저장하며, 저장한 데이터를 출력하는 공간이므로 입출력 장치에 포함하기도 함.
    












